\documentclass[onecolumn]{article}
\usepackage{array,booktabs,bytefield}
\usepackage{graphicx, here}
\begin{document}

\pagenumbering{roman}

\title{Control functionality for firewire devices}
\author{Takashi Sakamoto}
\date{2015/04/22}
\maketitle{}

\begin{abstract}

hoge

\end{abstract}

\section*{Acknowledgement}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}


\section{Features of FireWire sound devices}

In this section, I describe about a typical model of FireWire sound device, to consider about software stack for device control application.

\section{Requirements to control FireWire sound devices}

Devices connected to IEEE 1394 bus have much model-specific functionalities, thus the requirements are different between actual supported models. For reasonable discussion, I start to describe control application generals, then specialize the discussion to FireWire sound devices in a step by step.

\subsection{Requirements for control application generals}

Most of FireWire sound devices are designed to production use, while they're surely a kind of sound devices. In this subsection, I describe about requirements for control application generals.

\subsubsection{Enabled to access to devices}

These applications need to access to actual devices. These devices are on any peripheral buses such as PCI/PCI-Express bus, USB, IEEE 1394 bus and buses designed to this purpose and addressed by bus-specific way.

In a view of userspace applications, the ways to access to these buses are a kind of system resources. The application process should execute system call to change CPU mode in its execution path. Kernel should have corresponding drivers and functionalities.


\subsubsection{Have functionality to get available controls}

Usually, one control application supports several devices with the same chipset, while these devices have different control compositions due to vendor's customization. Control applications should have functionality to get available controls on the device.

For some devices, the available controls are hard-coded in control applications. On the other hand, some devices gives a way for control applications to get composition of available controls on the devices. In this case, the control application should have parsers for the information.


\subsubsection{Command-line user interface support to set parameters by scripts}

Control applications are for users, therefore it should have user interfaces. Command-line interface is required to set the configuration. In most case, an user has his or her preferred configuration of parameters to owned device. In this case, shell scripting satisfies the users.


\subsection{Model-specific requirements}

Many sound devices have been produced and they may have model-specific features. In this subsection, I describe about them as optional requirements


\subsubsection{Automatical launching support at detection}

Some devices require initial setup by software, or require firmware downloading from software. In most case, device drivers perform this, while control applications can also perform this. For this type of devices, control applications should automatically launch when the device is detected.

The control application sets previous state of parameters to utilize this functionality for better usage,


\subsubsection{Non-volatile memory support for write-only parameters}

Some devices give no ways for control applications to get devices' current parameters. Control applications should remember state of the devices, thus non-volatile memory is required in application side.

Even if the application have non-volatile memory, it cannot get to know initial state of the device. In this case, application developers need to know the state in device's specification.


\subsubsection{Event polling support for asynchronous messages}

Some devices transmit asynchronous messages and control applications should handle the messages depending on the aim. In this case, the control application should listen to the message in event loop, and notifies to users or processes something at receiving.


\subsubsection{Periodical access support for software controled registers}

Some devices have physical controls on their chassis. Most of them directly contol parameters of the device, while some devices depends actual controls to control applications. In this case, the control application periodically accesses to the device to get the state of physical controls, then perform actual changes to corresponding controls. This requirements seems to share the state of parameters.


\subsubsection{Graphical user interface support to set parameters for much controls}

Some devices have much controls or complicated controls. Command-line interface is sometimes difficult to give enough overview to users. In this case, graphical user interface is better for presentation.


\section{Requirements to control units on IEEE 1394 bus}

FireWire sound devices are units on IEEE 1394 bus, therefore the way to access to them is conformant to IEEE 1394.

\subsection{IEEE 1212 addressing support to refer to units}

IEEE 1212 defines 64bit fixed addressing scheme and IEEE 1394 utilizes the scheme. In the scheme, the address has hierarchy which consists of node ID, register space and CSR\footnote{Control and status register} offset.

TODO: image

The address spaces for register space and CSR offset are segmetated as specific roles below.


\begin{table}[ht]
	\centering
	\caption{{Each segments in IEEE 1212 address space}}
	\label{syt_interval}
	\begin{tabular}{lrr}
		\toprule
		Name		& Start address	   & End address \\
		\midrule
		Memory space	& 0x0000'0000'0000 & 0xffff'efff'ffff \\
		Private space	& 0xffff'e000'0000 & 0xffff'efff'ffff \\
		Register space	& 0xffff'f000'0000 & 0xffff'ffff'ffff \\
		\bottomrule
	\end{tabular}
\end{table}

Memory space is for node resources associated with memory. Private space is for vendor-dependent use and available for externally accessible bus address. Register space

\subsection{IEEE 1394 transaction support to read/write registers}


\subsection{Generation update support to handle bus reset}


\section{Investigation for potential frameworks}

\subsection{Linux FireWire subsystem interface}



\subsection{Libraw1394}

The libraw1394\footnote{http://git.kernel.org/cgit/libs/ieee1394/libraw1394.git} is a userspace I/O library for units on IEEE 1394 bus. This library is developed by Linux FireWire subsystem community\footnote{https://ieee1394.wiki.kernel.org/}. The design of this library is based on a handler structure, raw1394handle\_t. This handle works as a wrapper for both of old kernel ieee1394 interfaces and new kernel fw interfaces.




\subsection{ALSA Hardware Dependent interface}
\subsection{ALSA Control interface}
\subsection{FFADO D-Bus API}
\subsection{ALSA Control API}
\subsection{ALSA HControl, SControl and Mixer APIs}


\section{Case study to clear framework defectives}

\subsection{Intel HDA Controller/Codec}

ALSA Control interface

\subsection{FFADO D-Bus server}

hot-plugging and bus reset even if it's service daemon


\section{FFADO defectives}

FFADO is a project to develop user-land driver for FireWire sound devices\footnote{see my previous report.}. This project produces device control as well as streaming driver.

The device control consists of two softwares; ffado-dbus-server and ffado-mixer. They communicate each other by D-Bus interface. The ffado-dbus-server uses libffado to communicate to the actual IEEE 1394 units, and it defines the D-Bus interface for applications. Thus, some applications can communicate to the ffado-dbus-serer. But as of Apr. 2015, there're no such applications except for ffado-mixer.

The ffado-dbus-server has several defectives due to libffado. In this section, I describe about the defectives and the reason that ffado-dbus-server should not work as system daemon.

\subsection{Unable to handle bus reset}

The ffado-dbus-server has bugs for its handler of bus reset, therefore it cannot continue to communicate to IEEE 1394 units after bus reset. This is due to a wrong usage of libraw1394 handler.

When bus reset occurs, the IEEE 1394 bus updates its node topology, and changes generation. The generation is 32bit value and incremented each bus reset. After bus reset, transmitters of IEEE 1394 transaction should use the same value as current generation. If using different generation, the transaction is dropped by IEEE 1394 link layer.

In Linux FireWire subsystem, userspace applications should set the generation to a transaction parameter.

The libffado uses libraw1394 as its I/O backend. The basic operation of libraw1394 is based on a handler. The handler has a member for the generation and the userspace application has a responsibility to update the member in a handler.

The applications can achieve this by raw1394\_new\_handle\_on\_port() or raw1394\_set\_port() in bus reset handler. The libffado is not programmed to do it.


\subsection{Unable to detect hot plugging}

One of the causes of bus reset is adding/removing nodes to/from the IEEE 1394 bus. Therefore, IEEE 1394 unit discovery is required. As a result, some devices are newly available, or unavailable.

Since the libffado has bugs for its handler of bus reset, it cannot detect new devices or lost devices.

In usual usage, at first, applications construct an instance of FFADO::DeviceManager, then call initialize() method. This method seeks FireWire character devices which refers to 'port' in the libraw1394, then constructs an instance of FFADO::Ieee1394Service for each port. When initialized, the instance of FFADO::Ieee1394Service registers its bus reset handler to libraw1394. Finally, the instance of FFADO::DeviceManager registers its bus reset handler to the instance of Ieee1394Service. Next, applications call FFADO::DeviceManager::discover() to keep device instances into local list.

Both of bus reset handler in FFADO::DeviceManager and FFADO::Ieee1394Service don't update the local list, therefore device instances in the list is not eliminated. Furthermore, new instances of FFADO::Ieee1394Service corresponding to new libraw1394 ports are not created, thus the list cannot gain new device instances. Existed device instances in the list is going to be updated, but this operation fails because of the generation mismatch as described.


In this section, I describe some defectives of FFADO as service server daemon. This daemon program should be used as temporary service and unavailable for system daemon.


\section{ALSA Control Component and Interface}

ALSA includes some components corresponds to each functionality of actual sound devices\footnote{alsa-firewire-report}. One of the components is responsible for control functionality. In this document, it's referred to Control Component.

In this section, I describe the Control Component and its interface.


\subsection{ALSA Control Component and Element set}

In ALSA, each card instance\footnote{struct snd\_card} has a role as a ALSA Control Component, thus each driver has no need to add specific instances for Control Component.

Each controllable substance of actual card is represented as control elements\footnote{struct snd\_kcontrol}. Each driver adds some instances of control elements. Then, corresponding card instance manages the instances in a linked-list.

The instance can includes several control elements with the same feature. In this document, to distinguish the instance from single control element, it's referred to control element set.


\subsubsection{Control element identification}

When added to card instance, each control element gain incremented identical number from the card. There're two ways to identify each control element in this control element set. One is just the numerical number, another is a combination of some parameters with control element name.

The name of a control element set is used for included control elements, thus the control elements has the same name. To distinguish these control elements, numerical number is used. It's called as index.

Each driver can allow to add control element set with the same name. In this case, these control element sets are added by indicating the value of index for the first control element in each control element set so as no overlap index for the control elements with the same name.

To use the name and the offset for identification, the other parameters are also required. They're interface, device and subdevice. There're 6 types of the interface; card, hwdep, mixer, pcm, rawmidi, timer and sequencer. For usual control element set, the mixer interface is used. If the control element set is closely associated with certain ALSA components such as PCM, corresponding type of interface is used, then device and subdevice are also used to indicate the assosiated components\cite{alsa-driver}.

The parameters for these two ways are transferred with the same structure, struct snd\_ctl\_elem\_id\footnote{include/uapi/sound/asound.h in Linux kernel source code}. See Figure \ref{fig:control-element-id}.
Channel values for control element
\begin{figure}[htbp]
\small
\begin{verbatim}
#define SNDRV_CTL_ELEM_ID_NAME_MAXLEN	44

struct snd_ctl_elem_id {
    unsigned int numid;
    snd_ctl_elem_iface_t iface;
    unsigned int device;
    unsigned int subdevice;
    unsigned char name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
    unsigned int index;
};
\end{verbatim}
\caption{{Structure of identical information for control element}}
\label{fig:control-element-id}
\end{figure}


\subsubsection{Control element set information}

Control element set can have basic information. When adding new control element set, each driver gives the information.

Each control element has several channels. Originally, the channels in a control element are used to represent controlable substance in the same register. Currently the channel is used regardless of the actual register.

There're 7 types of control element; boolean, bytes, integer, integer64, iec958 and enumerated. See Figure \ref{fig:element-set-types}. The boolean, bytes, integer and integer64 control element has the corresponding type of value for its channels. The iec958 control element includes flags to describe parameters for IEC 60958. The enumerated control element has several labels to describes labeled values.

\begin{figure}[htbp]
\small
\begin{verbatim}
#define SNDRV_CTL_ELEM_TYPE_BOOLEAN     1
#define SNDRV_CTL_ELEM_TYPE_INTEGER     2
#define SNDRV_CTL_ELEM_TYPE_ENUMERATED  3
#define SNDRV_CTL_ELEM_TYPE_BYTES       4
#define SNDRV_CTL_ELEM_TYPE_IEC958      5
#define SNDRV_CTL_ELEM_TYPE_INTEGER64   6
\end{verbatim}
\caption{{Types of control element set}}
\label{fig:element-set-types}
\end{figure}

The integer and integer64 control element has a restriction of range for its value of each channel. Additionally, it has the value of step for its discrete values.

In the enumerated control element, the length of each label is restricted by 63 characters (64 bytes with terminator) and the length of total labels is limited by 64 * 1024 bytes including their terminators.

The information is represented by struct snd\_ctl\_elem\_info\footnote{include/uapi/sound/asound.h}. See Figure \ref{fig:element-set-info-structure}. This structure is used by each drivers to set information for control element.

\begin{figure}[htbp]
\small
\begin{verbatim}
struct snd_ctl_elem_info {
    struct snd_ctl_elem_id id;
    snd_ctl_elem_type_t type;
    unsigned int access;
    unsigned int count;
    __kernel_pid_t owner;
    union {
        struct {
            long min;
            long max;
            long step;
        } integer;
        struct {
            long long min;
            long long max;
            long long step;
        } integer64;
        struct {
            unsigned int items;
            unsigned int item;
            char name[64];
            __u64 names_ptr;
            unsigned int names_length;
        } enumerated;
        unsigned char reserved[128];
    } value;
    union {
        unsigned short d[4];
    } dimen;
    unsigned char reserved[64-4*sizeof(unsigned short)];
};
\end{verbatim}
\caption{{Structure for control element set information}}
\label{fig:element-set-info-structure}
\end{figure}


\subsubsection{Channel values for control element}

As described, control element can include several channels. The maximum number of channels included in an control element depends on the type of control element. See Table \ref{tbl:max-channels}

\begin{table}[H]
        \centering
        \caption{{The maximum number of channels for each control element}}
        \label{tbl:max-channels}
        \begin{tabular}{ccc} \toprule
		type & maximum \\ \midrule
		boolean & 128 \\
		byte & 512 \\
		integer & 128 \\
		integer64 & 64 \\
		iec958 & 1 \\
		enumerated & 128 \\ \bottomrule
        \end{tabular}
\end{table}

The limitation is due to structure to represent these values. See Figure \ref{fig:element-channel-value}. Actually, the value of boolean, enumerated is the same as integer, thus they have the same maximum number, 128.

This structure can deliver timestamp information when these values are read or changed, while there's no actual implementation.

\begin{figure}[htbp]
\small
\begin{verbatim}
struct snd_ctl_elem_value {
    struct snd_ctl_elem_id id;
    union {
        union {
            long value[128];
        } integer;
        union {
            long long value[64];
        } integer64;
        union {
            unsigned int item[128];
        } enumerated;
        union {
            unsigned char data[512];
        } bytes;
        struct snd_aes_iec958 iec958;
    } value;
    struct timespec tstamp;
    unsigned char reserved[128-sizeof(struct timespec)];
};
\end{verbatim}
\caption{{Channel value of a control element }}
\label{fig:element-channel-value}
\end{figure}


\subsubsection{Control element access type}

Control element has its own access type. The access type consists of some flags. See Figure \ref{fig:element-access-flags}. When adding a new control element set to card instance, each driver gives the flags as well as the other parameters. All control elements in a control element set basically have the same flags.

Usually, the controlable substance is readable and writable, thus both of read and write flags are used. If control element allows to handle threshold level, some tlv flags are used. When a control element set is added by userspace driver, user flag is used.

The timestamp flag means the read data includes timestamp at which channels of the control element are changed. The volatile flag means the channel of control element can be asynchronously changed.

\begin{figure}[htbp]
\small
\begin{verbatim}
#define SNDRV_CTL_ELEM_ACCESS_READ          (1<<0)
#define SNDRV_CTL_ELEM_ACCESS_WRITE         (1<<1)
#define SNDRV_CTL_ELEM_ACCESS_READWRITE     (SNDRV_CTL_ELEM_ACCESS_READ |
                                             SNDRV_CTL_ELEM_ACCESS_WRITE)
#define SNDRV_CTL_ELEM_ACCESS_VOLATILE      (1<<2)
#define SNDRV_CTL_ELEM_ACCESS_TIMESTAMP     (1<<3)
#define SNDRV_CTL_ELEM_ACCESS_TLV_READ      (1<<4)
#define SNDRV_CTL_ELEM_ACCESS_TLV_WRITE     (1<<5)
#define SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE (SNDRV_CTL_ELEM_ACCESS_TLV_READ |
                                             SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)
#define SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND   (1<<6)
#define SNDRV_CTL_ELEM_ACCESS_INACTIVE      (1<<8)
#define SNDRV_CTL_ELEM_ACCESS_LOCK          (1<<9)
#define SNDRV_CTL_ELEM_ACCESS_OWNER         (1<<10)
#define SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK  (1<<28)
#define SNDRV_CTL_ELEM_ACCESS_USER          (1<<29)
\end{verbatim}
\caption{{Element access flags}}
\label{fig:element-access-flags}
\end{figure}

These flags tell implementation requirements to userspace applications. For example, when an control element has read flag, userspace applications can execute read operation to the control element. Of cource, each driver should have corresponding implementation.

Basically, some flags in a control element is mutable, while the inactive, lock and owner flags are immutable to describe current status of the control element. The inactive flag means the control element exists but is not activated. The combination of lock and owner flags means the locking state of control element.


\subsubsection{Locking state of control element}

An userspace application can lock arbitrary control elements. The process to lock the control element is called as 'owner'. When locked, the other processes can read channels of the control element, while cannot write to channels of the control element.

In locking state, when reading information of the control element, it has lock flag. When the owner process read the information, the control element has lock and owner flag.

For both owner process and non-owner process, the information includes owner's PID. In unlocking state, a control element gives -1 for the PID field in information data.


\subsubsection{Threshold level representation and operation for sound pressure}

Generally, in human perception, the maximum and minimum signal level which human can perceive as sound are limited. The perceptived sound is calles as loudness and its level is not linearly increased even if the signal level is linearly increased. Additionally, the loudness level differs depending on signal frequency. There's a series of study about this\footnote{i.e. ISO 226:2003}.

In acoustics engineering, common logarithm\footnote{Logarithm based on 10.} is used for a formula between signal level and loudness level. This way is too primitive and rough, but a simple, easy and practical. In this way, the loudness level is referred to 'sound pressure level', calculated by equation \ref{eq:decibel}.

\begin{equation}
L_p = 10 \log_{10} \frac{p}{p_0} \label{eq:decibel}
\end{equation}

Here, $L_p$ is sound pressure level (decibell, dB), p is measured sound pressure(Pa), $p_0$ is minimum sound pressure level and defined with $2 \times 10^-5$ (Pa).

In most sound devices, corresponding sound drivers control the sound pressure by reading/writing their registers. The driver developers cannot know actual sound pressure, but can know maximum and minimum value on the registers. If incrementing the value of registers can linearly increase the sound pressure, there're some demands for application developer to calculate read/write value according to sound pressure level. Then, some tlv parameters should be given, such as the required value change to change pressure level by a unit of 0.1 dB.

ALSA Control Component refers the threshold level as 'tlv' and gives a way to transfer tlv parameters.

Originally, ALSA Control Component allows each driver to have pre-defined tlv information. This implements one tlv information to each driver instance and allows applications to read the information.

The tlv information is represented by an array consists of unsigned int elements and  has hierarchic structure. The data is capculated by container. Each container has a type in its first element, and the number of included data in its second element. There's just one type of container, SNDRV\_CTL\_TLVT\_DB\_SCALE.

<TODO: graphic>

In 2006, tlv operations are expanded\footnote{commit 8aa9b586e42099817163aba01d925c2660c4dbbe in Linux kernel source code}. Write and command operations were added. Later, new types of container were added.

According to these implementation, each driver can have flexible information for tlv. On the other hand, as if Linux 4.1, no kernel-land drivers supports the command operation.


\subsubsection{Control event notification}

ALSA Control Component supports event notification. As of Linux 4.1, events for control elements are supported. The supported events are removing, changing information, changing the value of channels and handling tlv information.

\begin{figure}[htbp]
\small
\begin{verbatim}
enum sndrv_ctl_event_type {
    SNDRV_CTL_EVENT_ELEM = 0,
    SNDRV_CTL_EVENT_LAST = SNDRV_CTL_EVENT_ELEM,
};

#define SNDRV_CTL_EVENT_MASK_VALUE  (1<<0)
#define SNDRV_CTL_EVENT_MASK_INFO   (1<<1)
#define SNDRV_CTL_EVENT_MASK_ADD    (1<<2)
#define SNDRV_CTL_EVENT_MASK_TLV    (1<<3)
#define SNDRV_CTL_EVENT_MASK_REMOVE (~0U)
\end{verbatim}
\caption{{Defined events}}
\label{defined-events}
\end{figure}

The events for control elements are transferred with identical information and event mask.

\subsection{Driver implementation}

ALSA Control Component has both of kernel API and userspace API, thus drivers can be implemented in both sides.

\subsubsection{Kernel-land driver}

When adding a new control element set, ALSA kernel-land drivers call snd\_ctl\_new1() with a template. The template is represented by \'struct snd\_kcontrol\_new\'.

\begin{figure}[htbp]
\small
\begin{verbatim}
struct snd_kcontrol_new {
    snd_ctl_elem_iface_t iface;
    unsigned int device;
    unsigned int subdevice;
    const unsigned char *name;
    unsigned int index;
    unsigned int access;
    unsigned int count;
    snd_kcontrol_info_t *info;
    snd_kcontrol_get_t *get;
    snd_kcontrol_put_t *put;
    union {
        snd_kcontrol_tlv_rw_t *c;
        const unsigned int *p;
    } tlv;
    unsigned long private_value;
};
\end{verbatim}
\caption{{Template structure for control element}}
\label{control-element-template}
\end{figure}

This structure includes enough members to build an instance of ALSA control element set. Four operations are defined as a callback functions.

\begin{description}
\small
\item[snd\_kcontrol\_info\_t] \mbox{} \\
For detail information about the element set
\item[snd\_kcontrol\_get\_t] \mbox{} \\
For read operation of the element set
\item[snd\_kcontrol\_put\_t] \mbox{} \\
For write operation of the element set
\item[snd\_kctl\_tlv\_rw\_t] \mbox{} \\
For threshold level operation of the element set
\end{description}

In info callback function, each driver should fill enough members of passed 'struct snd\_ctl\_elem\_info'.

In read/write callback function, each driver can control actual devices.

In tlv callback function, each driver can modify its own tlv information or keep/handle given tlv information.

The added control element sets are removed when the device is removed or the driver is unloaded.


\subsubsection{User-land driver}

ALSA control interface allows userspace applications to add/replace/remove control element sets into registered card instances. The operation is implemented in ioctl(2) commands. In this document, the userspace is called as an user-land driver.

\begin{figure}[htbp]
\small
\begin{verbatim}
#define SNDRV_CTL_IOCTL_ELEM_ADD        _IOWR('U', 0x17, struct snd_ctl_elem_info)
#define SNDRV_CTL_IOCTL_ELEM_REPLACE    _IOWR('U', 0x18, struct snd_ctl_elem_info)
#define SNDRV_CTL_IOCTL_ELEM_REMOVE     _IOWR('U', 0x19, struct snd_ctl_elem_id)
\end{verbatim}
\caption{{ioctl(2) commands to handle control element set in userspace}}
\label{ioctl-commands-userspace-element}
\end{figure}

When adding a new control element set, userspace driver gives information data with identical information and basic parameters. In this case, the owner field is used for a different purpose. The given value to owner field is used for the number of control elements in the control element set. On the other hand, the count field is used for the number of channels which an control element has.

If registering tlv information, tlv write flag should be given to the information. Then, write operation can be available. In this case, the control elements automatically has tlv callback flag for an internal reason of ALSA Control Component. Actually, to allow the other applications to read tlv information, the control element set should have tlv read flag.

The userspace driver should listen to control notification to catch value change of each channel in control element.

The remove ioctl is used to remove an control element set identified by the given information. I note that these added control element set can be also removed by the other applications. Additionally, when no applications remove these control element set, they exist till the character device exists.


\subsection{ALSA Control Interface for control elements}

ALSA Control interface is designed to basic operations such as open(2)/ioctl(2)/close(2). Their entry point is ALSA Control character device.

When opening one of the chracter devices and get a file descriptor, userspace applications can handle control elements via the file descriptor. These operations are defined to ioctl(2) commands.

\begin{figure}[htbp]
\small
\begin{verbatim}
#define SNDRV_CTL_IOCTL_ELEM_LIST _IOWR('U', 0x10, struct snd_ctl_elem_list)
#define SNDRV_CTL_IOCTL_ELEM_INFO _IOWR('U', 0x11, struct snd_ctl_elem_info)
#define SNDRV_CTL_IOCTL_ELEM_READ _IOWR('U', 0x12, struct snd_ctl_elem_value)
#define SNDRV_CTL_IOCTL_ELEM_WRITE _IOWR('U', 0x13, struct snd_ctl_elem_value)
#define SNDRV_CTL_IOCTL_ELEM_LOCK _IOW('U', 0x14, struct snd_ctl_elem_id)
#define SNDRV_CTL_IOCTL_ELEM_UNLOCK _IOW('U', 0x15, struct snd_ctl_elem_id)
#define SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS _IOWR('U', 0x16, int)
#define SNDRV_CTL_IOCTL_TLV_READ _IOWR('U', 0x1a, struct snd_ctl_tlv)
#define SNDRV_CTL_IOCTL_TLV_WRITE _IOWR('U', 0x1b, struct snd_ctl_tlv)
#define SNDRV_CTL_IOCTL_TLV_COMMAND _IOWR('U', 0x1c, struct snd_ctl_tlv)
\end{verbatim}
\caption{{ioctl(2) commands to handle control element}}
\label{ioctl-handle-element}
\end{figure}

Userspace applications can get the list of identical informations of existed control element.

\begin{figure}[htbp]
\small
\begin{verbatim}
struct snd_ctl_elem_list {
	unsigned int offset;
	unsigned int space;
	unsigned int used;
	unsigned int count;
	struct snd_ctl_elem_id __user *pids;
	unsigned char reserved[50];
};
\end{verbatim}
\caption{{Structure for control element list}}
\label{snd-ctl-elem-list}
\end{figure}

There're two ways to use this operation. The first way is to get the number of control element. When the space field is zero, the count field is filled with the number of control element.

Another way is to get the list of indentical informations for existed control element. In this case, the pids field has a pointer for pre-allocated memory to identical information list, and the space field is filled with the number of allocated memory at unit of identical information structure.

To avoid allocating excess memory object in kernel space, the maximum number of space is limited within 16384. If there're more control element, the offset fields can be available to indicate an offset from the first control element with minimum numerical number.

The lock operation is used to own a control element. The unlock operation is used to release the control element. If the control element is owned by the other userspace applications, the unlock operation fails.

If userspace applications want to receive control element notification, the application should call the subscribe events operation in advance. Then, these notification can be readable from a file descriptor.

\begin{figure}[htbp]
\small
\begin{verbatim}
struct snd_ctl_event {
    int type;
    union {
        struct {
            unsigned int mask;
            struct snd_ctl_elem_id id;
        } elem;
        unsigned char data8[60];
    } data;
};
\end{verbatim}
\caption{{Structure for control notification event}}
\label{snd-ctl-event}
\end{figure}

When the control element has corresponding flags, tlv read/write/command operations are available.


\subsection{ALSA library}

ALSA project develops an userspace library to give higher abstructions for each interfaces such as PCM or Sequencer. In this section, I describe about basic design of ALSA library and control API.


\subsubsection{Configuration space and plugins}

ALSA interface consists of PCM, Compress\footnote{Currently ALSA library doesn't support this interface.}, Control, RawMidi, Sequencer, Timer and Hardware Dependent (HwDep). They have its own character devices. The main purpose of ALSA library is to capsulate raw access to character deivces and to add software functional implementation to the access. This is called as configuration space.

The configuration space is based on ALSA configuration files\footnote{/usr/share/alsa/alsa.conf.d/*, /etc/asound.conf and ~/.asoundrc}. These configuration files describe node settings for each interfaces.

When userspace applications open handles for ALSA interfaces, ALSA library parses these configuration files to construct configuration space. Userspace applications can open handlers against the nodes.

Each node setting can have plugin entry. The plugin is to extend node functionality with software implementation. For ALSA Control Interface, hw and shm plugin are included in ALSA library.

The hw plugin execute raw access to ALSA Control character device. The shm plugin is designed for interprocess communication.


\subsubsection{External control plugins}

ALSA library allows to develop plugins externally. This is called as external control plugin. As of alsa-plugins 1.0.29, arcam, maemo, oss and pulse plugins are included.

The external control plugin can be available by the same way as control plugins in ALSA library.


\subsubsection{Control API}

Control API is designed to use a handler, snd\_ctl\_t for operation. The handler is an opaque pointer for struct \_snd\_ctl\footnote{src/control/control\_local.h} and userspace applications cannot refer to each member of the structure.

\begin{figure}[htbp]
\small
\begin{verbatim}
struct _snd_ctl {
    void *open_func;
    char *name;
    snd_ctl_type_t type;
    const snd_ctl_ops_t *ops;
    void *private_data;
    int nonblock;
    int poll_fd;
    struct list_head async_handlers;
};
\end{verbatim}
\caption{{Control handler internals}}
\label{control-handler-internals}
\end{figure}

The type member means the type of plugin to which the handler is assigend. As of ALSA library 1.0.29, four types are defined, while INET type has no actual plugin implementation.

\begin{figure}[htbp]
\small
\begin{verbatim}
typedef enum _snd_ctl_type {
    SND_CTL_TYPE_HW,
    SND_CTL_TYPE_SHM,
    SND_CTL_TYPE_INET,
    SND_CTL_TYPE_EXT
} snd_ctl_type_t;
\end{verbatim}
\caption{{Types of handlers}}
\label{snd-ctl-type-t}
\end{figure}

When opening the handler, userspace applications call snd\_ctl\_open() with the name of node and a mode flag. As of ALSA library 1.0.29, there're three types of handler mode flags. As of ALSA library 1.0.29 and Linux kernel 4.1, there're no implementation for write operation, therefore readonly flag is meaningless.

\begin{figure}[htbp]
\small
\begin{verbatim}
#define SND_CTL_NONBLOCK		0x0001
#define SND_CTL_ASYNC			0x0002
#define SND_CTL_READONLY		0x0004
\end{verbatim}
\caption{{Handler flags}}
\label{handler-flags}
\end{figure}

\begin{figure}[htbp]
\small
\begin{verbatim}
typedef struct _snd_ctl snd_ctl_t;
int snd_ctl_open(snd_ctl_t **ctl, const char *name, int mode);
int snd_ctl_open_lconf(snd_ctl_t **ctl, const char *name, int mode,
                       snd_config_t *lconf);
int snd_ctl_open_fallback(snd_ctl_t **ctl, snd_config_t *root, const char *name,
                          const char *orig_name, int mode);
int snd_ctl_close(snd_ctl_t *ctl);
\end{verbatim}
\caption{{Handler operations}}
\label{handler-operations}
\end{figure}

Control API is designed to use opaque pointers for fundamental structures. Thus, userspace applications cannot directrly refer to each members in the structure.

\begin{figure}[htbp]
\small
\begin{verbatim}
typedef struct _snd_ctl_elem_id snd_ctl_elem_id_t;
typedef struct _snd_ctl_elem_list snd_ctl_elem_list_t;
typedef struct _snd_ctl_elem_info snd_ctl_elem_info_t;
typedef struct _snd_ctl_elem_value snd_ctl_elem_value_t;
typedef struct _snd_ctl_event snd_ctl_event_t;
\end{verbatim}
\caption{{Opaque pointers for fundamental structures}}
\label{opaque-pointers}
\end{figure}



\begin{figure}[htbp]
\small
\begin{verbatim}
int snd_ctl_poll_descriptors_count(snd_ctl_t *ctl);
int snd_ctl_poll_descriptors(snd_ctl_t *ctl, struct pollfd *pfds,
                             unsigned int space);
int snd_ctl_poll_descriptors_revents(snd_ctl_t *ctl, struct pollfd *pfds,
                                unsigned int nfds, unsigned short *revents);
int snd_ctl_subscribe_events(snd_ctl_t *ctl, int subscribe);
\end{verbatim}
\caption{{Read-related operations}}
\label{read-related-operations}
\end{figure}


\begin{figure}[htbp]
\small
\begin{verbatim}
int snd_ctl_elem_list(snd_ctl_t *ctl, snd_ctl_elem_list_t *list);
int snd_ctl_elem_info(snd_ctl_t *ctl, snd_ctl_elem_info_t *info);
int snd_ctl_elem_read(snd_ctl_t *ctl, snd_ctl_elem_value_t *value);
int snd_ctl_elem_write(snd_ctl_t *ctl, snd_ctl_elem_value_t *value);
int snd_ctl_elem_lock(snd_ctl_t *ctl, snd_ctl_elem_id_t *id);
int snd_ctl_elem_unlock(snd_ctl_t *ctl, snd_ctl_elem_id_t *id);
int snd_ctl_elem_tlv_read(snd_ctl_t *ctl, const snd_ctl_elem_id_t *id,
                          unsigned int *tlv, unsigned int tlv_size);
int snd_ctl_elem_tlv_write(snd_ctl_t *ctl, const snd_ctl_elem_id_t *id,
                           const unsigned int *tlv);
int snd_ctl_elem_tlv_command(snd_ctl_t *ctl, const snd_ctl_elem_id_t *id,
                             const unsigned int *tlv);
\end{verbatim}
\caption{{Element operations}}
\label{element-operations}
\end{figure}


\begin{figure}[htbp]
\small
\begin{verbatim}
int snd_ctl_nonblock(snd_ctl_t *ctl, int nonblock);
int snd_ctl_abort(snd_ctl_t *ctl);
int snd_async_add_ctl_handler(snd_async_handler_t **handler, snd_ctl_t *ctl, 
			snd_async_callback_t callback, void *private_data);
snd_ctl_t *snd_async_handler_get_ctl(snd_async_handler_t *handler);
\end{verbatim}
\caption{{Asynchronous operations}}
\label{async-operations}
\end{figure}

\subsubsection{Setup control API}

\subsubsection{High level control API}

\subsubsection{Mixer API}



\subsubsection{Use Case Manager}

\subsection{ALSA control daemon}

\section{ALSA hardware dependent interface}

\section{Linux Hot-plugging support}

\subsection{udev}

\subsection{inotify}

\section{Requirements for control application}

\section{Weakpoints of each implementation}

\subsection{FFADO D-Bus server}

FFADO D-Bus server is a defective daemon. It cannot handle hot-plugging of any units on IEEE 1394 bus. This is due to restrictions of libffado.

\subsection{ALSA Control Interface}

ALSA Control Interface has a lack of functionality for matrix mixer.

\subsection{ALSA library}



\subsection{}
\subsection{}

\newpage

\begin{thebibliography}{99}

\addcontentsline{toc}{section}{References}

\bibitem{alsa-firewire-report}
Enhancement of ALSA firewire stack (2015, Takashi Sakamoto) \\
https://github.com/takaswie/alsa-firewire-report

\bibitem{alsa-driver}
Writing an ALSA Driver (2005, Takashi Iwai) \\
http://www.alsa-project.org/main/index.php/ALSA\_Driver\_Documentation

\bibitem{ieee1394-1}
hoge

\end{thebibliography}

\newpage

\appendix

\addcontentsline{toc}{section}{Appendices}
\addtocontents{toc}{\protect\setcounter{tocdepth}{-1}}

\section{hoge}

\section{fuga}

\end{document}
