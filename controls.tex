\documentclass[onecolumn]{article}
\usepackage{array,booktabs,bytefield}
\usepackage{graphicx, here}
\begin{document}

\pagenumbering{roman}

\title{Control functionality for firewire devices}
\author{Takashi Sakamoto}
\date{2015/04/22}
\maketitle{}

\begin{abstract}

hoge

\end{abstract}

\section*{Acknowledgement}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}


\section{Firewire sound device model}

In this section, I describe about a typical model of FireWire sound device, to consider about software stack for device control application.




\section{Implementations of each chipset}

\subsection{BeBoB}

\subsection{Fireworks}

\subsection{OXFW}

\subsection{Dice}

\subsection{Digidesign 002/003 family}

\subsection{TASCAM FireWire series}

\section{FFADO control functionality}

\subsection{libffado}

\subsection{FFADO D-bus interface}

\subsection{FFADO D-bus server}

\subsection{FFADO Mixer}

\section{}

\section{Linux firewire subsystem}

\subsection{fw character devices}


\section{ALSA Control Component and Interface}

ALSA includes some components corresponds to each functionality of actual sound devices\footnote{alsa-firewire-report}. One of the components is responsible for control functionality. In this document, it's referred to Control Component.

In this section, I describe the Control Component and its interface.


\subsection{ALSA Control Component and Element set}

In ALSA, each card instance\footnote{struct snd\_card} has a role as a ALSA Control Component, thus each driver has no need to add specific instances for Control Component.

Each controllable substance of actual card is represented as control elements\footnote{struct snd\_kcontrol}. Each driver adds some instances of control elements. Then, corresponding card instance manages the instances in a linked-list.

The instance can includes several control elements with the same feature. In this document, to distinguish the instance from single control element, it's referred to control element set.


\subsubsection{Control element identification}

When added to card instance, each control element gain incremented identical number from the card. There're two ways to identify each control element in this control element set. One is just the numerical number, another is a combination of some parameters with control element name.

The name of a control element set is used for included control elements, thus the control elements has the same name. To distinguish these control elements, numerical number is used. It's called as index.

Each driver can allow to add control element set with the same name. In this case, these control element sets are added by indicating the value of index for the first control element in each control element set so as no overlap index for the control elements with the same name.

To use the name and the offset for identification, the other parameters are also required. They're interface, device and subdevice. There're 6 types of the interface; card, hwdep, mixer, pcm, rawmidi, timer and sequencer. For usual control element set, the mixer interface is used. If the control element set is closely associated with certain ALSA components such as PCM, corresponding type of interface is used, then device and subdevice are also used to indicate the assosiated components\cite{alsa-driver}.

The parameters for these two ways are transferred with the same structure, struct snd\_ctl\_elem\_id\footnote{include/uapi/sound/asound.h in Linux kernel source code}. See Figure \ref{fig:control-element-id}.
Channel values for control element
\begin{figure}[htbp]
\small
\begin{verbatim}
#define SNDRV_CTL_ELEM_ID_NAME_MAXLEN	44

struct snd_ctl_elem_id {
    unsigned int numid;
    snd_ctl_elem_iface_t iface;
    unsigned int device;
    unsigned int subdevice;
    unsigned char name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
    unsigned int index;
};
\end{verbatim}
\caption{{Structure of identical information for control element}}
\label{fig:control-element-id}
\end{figure}


\subsection{Control element access type}

Control element has its own access type. The access type consists of some flags. See Figure \ref{fig:element-access-flags}. When added to card instance, each driver gives the flags with the other parameters. As of Linux kernel 4.1, there're some flags with no actual implementation.

Usually, the controlable substance is readable and writable, thus both of read and write flags are used. If the substance is changable by the other than drivers, volatile flag is used. To transfer when changing state, timestamp flag is used. If control element allows to handle threshold level, tlv flags are used. When control element is added by userspace driver, user flag is used.

The other fields are used to describe the state of control element.

\begin{figure}[htbp]
\small
\begin{verbatim}
#define SNDRV_CTL_ELEM_ACCESS_READ          (1<<0)
#define SNDRV_CTL_ELEM_ACCESS_WRITE         (1<<1)
#define SNDRV_CTL_ELEM_ACCESS_READWRITE     (SNDRV_CTL_ELEM_ACCESS_READ |
                                             SNDRV_CTL_ELEM_ACCESS_WRITE)
#define SNDRV_CTL_ELEM_ACCESS_VOLATILE      (1<<2)
#define SNDRV_CTL_ELEM_ACCESS_TIMESTAMP     (1<<3)
#define SNDRV_CTL_ELEM_ACCESS_TLV_READ      (1<<4)
#define SNDRV_CTL_ELEM_ACCESS_TLV_WRITE     (1<<5)
#define SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE (SNDRV_CTL_ELEM_ACCESS_TLV_READ |
                                             SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)
#define SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND   (1<<6)
#define SNDRV_CTL_ELEM_ACCESS_INACTIVE      (1<<8)
#define SNDRV_CTL_ELEM_ACCESS_LOCK          (1<<9)
#define SNDRV_CTL_ELEM_ACCESS_OWNER         (1<<10)
#define SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK  (1<<28)
#define SNDRV_CTL_ELEM_ACCESS_USER          (1<<29)
\end{verbatim}
\caption{{Element access flags}}
\label{fig:element-access-flags}
\end{figure}

As of Linux kernel 4.1, volatile and timestamp flag has no actual implementation. Furthermore, inactive flag is not used. The 30 and 31 value had already been obsoleted.

Each control element has set of these flags. In fact, the instance of control element set manages the status.


\subsubsection{Control element set information}

Control element set can have basic information. When adding new control element set, each driver gives the information.

Each control element has several channels. Originally, the channels in a control element are used to represent controlable substance in the same register. Currently the channel is used regardless of the actual register.

There're 7 types of control element; boolean, bytes, integer, integer64, iec958 and enumerated. See Figure \ref{fig:element-set-types}. The boolean, bytes, integer and integer64 control element has the corresponding type of value for its channels. The iec958 control element includes flags to describe parameters for IEC 60958. The enumerated control element has several labels to describes labeled values.

\begin{figure}[htbp]
\small
\begin{verbatim}
#define SNDRV_CTL_ELEM_TYPE_BOOLEAN     1
#define SNDRV_CTL_ELEM_TYPE_INTEGER     2
#define SNDRV_CTL_ELEM_TYPE_ENUMERATED  3
#define SNDRV_CTL_ELEM_TYPE_BYTES       4
#define SNDRV_CTL_ELEM_TYPE_IEC958      5
#define SNDRV_CTL_ELEM_TYPE_INTEGER64   6
\end{verbatim}
\caption{{Types of control element set}}
\label{fig:element-set-types}
\end{figure}

The integer and integer64 control element has a restriction of range for its value of each channel. Additionally, it has the value of step for its discrete values.

In the enumerated control element, the length of each label is restricted by 63 characters (64 bytes with terminator) and the length of total labels is limited by 64 * 1024 bytes including their terminators.

The information is represented by struct snd\_ctl\_elem\_info\footnote{include/uapi/sound/asound.h}. See Figure \ref{fig:element-set-info-structure}. This structure is used by each drivers to set information for control element.

\begin{figure}[htbp]
\small
\begin{verbatim}
struct snd_ctl_elem_info {
    struct snd_ctl_elem_id id;
    snd_ctl_elem_type_t type;
    unsigned int access;
    unsigned int count;
    __kernel_pid_t owner;
    union {
        struct {
            long min;
            long max;
            long step;
        } integer;
        struct {
            long long min;
            long long max;
            long long step;
        } integer64;
        struct {
            unsigned int items;
            unsigned int item;
            char name[64];
            __u64 names_ptr;
            unsigned int names_length;
        } enumerated;
        unsigned char reserved[128];
    } value;
    union {
        unsigned short d[4];
    } dimen;
    unsigned char reserved[64-4*sizeof(unsigned short)];
};
\end{verbatim}
\caption{{Structure for control element set information}}
\label{fig:element-set-info-structure}
\end{figure}

\subsubsection{Channel values for control element}

As described, control element can include several channels. The maximum number of channels included in an control element depends on the type of control element. See Table \ref{tbl:max-channels}

\begin{table}[H]
        \centering
        \caption{{The maximum number of channels for each control element}}
        \label{tbl:max-channels}
        \begin{tabular}{ccc} \toprule
		type & maximum \\ \midrule
		boolean & 128 \\
		byte & 512 \\
		integer & 128 \\
		integer64 & 64 \\
		iec958 & 1 \\
		enumerated & 128 \\ \bottomrule
        \end{tabular}
\end{table}

The limitation is due to structure to represent these values. See Figure \ref{fig:element-channel-value}. Actually, the value of boolean, enumerated is the same as integer, thus they have the same maximum number, 128.

This structure can deliver timestamp information when these values are read or changed, while there's no actual implementation.

\begin{figure}[htbp]
\small
\begin{verbatim}
struct snd_ctl_elem_value {
    struct snd_ctl_elem_id id;
    union {
        union {
            long value[128];
        } integer;
        union {
            long long value[64];
        } integer64;
        union {
            unsigned int item[128];
        } enumerated;
        union {
            unsigned char data[512];
        } bytes;
        struct snd_aes_iec958 iec958;
    } value;
    struct timespec tstamp;
    unsigned char reserved[128-sizeof(struct timespec)];
};
\end{verbatim}
\caption{{Channel value of a control element }}
\label{fig:element-channel-value}
\end{figure}

\subsubsection{Lock and own of control element}



\subsubsection{ALSA control element set added by kernel-land driver}

When adding new element sets, ALSA kernel-land drivers call snd\_ctl\_new1() with a template. The template is represented by \'struct snd\_kcontrol\_new\'.

\begin{figure}[htbp]
\small
\begin{verbatim}
struct snd_kcontrol_new {
    snd_ctl_elem_iface_t iface;
    unsigned int device;
    unsigned int subdevice;
    const unsigned char *name;
    unsigned int index;
    unsigned int access;
    unsigned int count;
    snd_kcontrol_info_t *info;
    snd_kcontrol_get_t *get;
    snd_kcontrol_put_t *put;
    union {
        snd_kcontrol_tlv_rw_t *c;
        const unsigned int *p;
    } tlv;
    unsigned long private_value;
};
\end{verbatim}
\caption{{Template structure for control element}}
\label{control-element-template}
\end{figure}

This structure includes enough members to build an instance of ALSA control element set. Some operations of the element set is implemented as four callback functions. According to ALSA driver implementation guide\cite{alsa-driver}, the purposes of these callback functions are:

\begin{description}
\small
\item[snd\_kcontrol\_info\_t] \mbox{} \\
For detail information about the element set
\item[snd\_kcontrol\_get\_t] \mbox{} \\
For read operation of the element set
\item[snd\_kcontrol\_put\_t] \mbox{} \\
For write operation of the element set
\item[snd\_kctl\_tlv\_rw\_t] \mbox{} \\
For threshold level operation of the element set
\end{description}

In info callback function, each driver should fill enough members of \'struct snd\_ctl\_elem\_info\'. This structure includes union field to describe parameters for each types of element set.

\subsection{Threshold level representation}

To describe information about threshold level, 


\subsubsection{ALSA control element set added by user-land driver}

ALSA control interface allows userspace applications to add/replace/remove control element sets into registered card instances. The operation is implemented in ioctl(2) commands.

\begin{figure}[htbp]
\small
\begin{verbatim}
#define SNDRV_CTL_IOCTL_ELEM_ADD        _IOWR('U', 0x17, struct snd_ctl_elem_info)
#define SNDRV_CTL_IOCTL_ELEM_REPLACE    _IOWR('U', 0x18, struct snd_ctl_elem_info)
#define SNDRV_CTL_IOCTL_ELEM_REMOVE     _IOWR('U', 0x19, struct snd_ctl_elem_id)
\end{verbatim}
\caption{{ioctl(2) commands to handle control element set in userspace}}
\label{ioctl-commands-userspace-element}
\end{figure}






\begin{verbatim}
struct snd_ctl_elem_info {
    struct snd_ctl_elem_id id;    /* W: element ID */
    snd_ctl_elem_type_t type;    /* R: value type - SNDRV_CTL_ELEM_TYPE_* */
    unsigned int access;        /* R: value access (bitmask) - SNDRV_CTL_ELEM_ACCESS_* */
    unsigned int count;        /* count of values */
    __kernel_pid_t owner;        /* owner's PID of this control */
    union {
        struct {
            long min;        /* R: minimum value */
            long max;        /* R: maximum value */
            long step;        /* R: step (0 variable) */
        } integer;
        struct {
            long long min;        /* R: minimum value */
            long long max;        /* R: maximum value */
            long long step;        /* R: step (0 variable) */
        } integer64;
        struct {
            unsigned int items;    /* R: number of items */
            unsigned int item;    /* W: item number */
            char name[64];        /* R: value name */
            __u64 names_ptr;    /* W: names list (ELEM_ADD only) */
            unsigned int names_length;
        } enumerated;
        unsigned char reserved[128];
    } value;
    union {
        unsigned short d[4];        /* dimensions */
        unsigned short *d_ptr;        /* indirect - obsoleted */
    } dimen;
    unsigned char reserved[64-4*sizeof(unsigned short)];
};
\end{verbatim}

\begin{verbatim}
struct snd_ctl_elem_value {
    struct snd_ctl_elem_id id;    /* W: element ID */
    unsigned int indirect: 1;    /* obsoleted */
    union {
        union {
            long value[128];
            long *value_ptr;    /* obsoleted */
        } integer;
        union {
            long long value[64];
            long long *value_ptr;    /* obsoleted */
        } integer64;
        union {
            unsigned int item[128];
            unsigned int *item_ptr;    /* obsoleted */
        } enumerated;
        union {
            unsigned char data[512];
            unsigned char *data_ptr;    /* obsoleted */
        } bytes;
        struct snd_aes_iec958 iec958;
    } value;        /* RO */
    struct timespec tstamp;
    unsigned char reserved[128-sizeof(struct timespec)];
};
\end{verbatim}

\subsubsection{ALSA control component in user-land}

\subsection{ALSA library}

\subsubsection{Control API}

\subsubsection{Configuration space and external control plugins}

\subsubsection{Setup control API}

\subsubsection{High level control API}

\subsubsection{Mixer API}

\subsubsection{Use Case Manager}

\subsection{ALSA control daemon}

\section{ALSA hardware dependent interface}

\section{Linux Hot-plugging support}

\subsection{udev}

\subsection{inotify}

\section{Requirements for control application}

\section{Weakpoints of each implementation}

\subsection{FFADO D-Bus server}

FFADO D-Bus server is a defective daemon. It cannot handle hot-plugging of any units on IEEE 1394 bus. This is due to restrictions of libffado.

\subsection{ALSA Control Interface}

ALSA Control Interface has a lack of functionality for matrix mixer.

\subsection{ALSA library}



\subsection{}
\subsection{}

\newpage

\begin{thebibliography}{99}

\addcontentsline{toc}{section}{References}

\bibitem{alsa-firewire-report}
Enhancement of ALSA firewire stack (2015, Takashi Sakamoto) \\
https://github.com/takaswie/alsa-firewire-report

\bibitem{alsa-driver}
Writing an ALSA Driver (2005, Takashi Iwai) \\
http://www.alsa-project.org/main/index.php/ALSA\_Driver\_Documentation

\bibitem{ieee1394-1}
hoge

\end{thebibliography}

\newpage

\appendix

\addcontentsline{toc}{section}{Appendices}
\addtocontents{toc}{\protect\setcounter{tocdepth}{-1}}

\section{hoge}

\section{fuga}

\end{document}
